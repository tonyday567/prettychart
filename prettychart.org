* prettychart

[[https://hackage.haskell.org/package/prettychart][https://img.shields.io/hackage/v/prettychart.svg]] [[https://github.com/tonyday567/chart-svg/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/prettychart/workflows/haskell-ci/badge.svg]]

This library contains:

- A chart server, for use in conjunction with ghci, or other live coding situations. (See Chartpretty.Server)
- anyChart, which attempts to convert text (of numbers) to a chart. (See Chartpretty.Any)
- Some useful chart patterns that didn't make the cut in chart-svg (See Chartpretty.Charts)

* Usage
** live coding

The server can be used to view and develop chart-svg charts.

#+begin_src haskell :results output
> (display, quit) <- startChartServer (Just "prettychart")
Setting phaser>s  to stun... (port 9160) (ctrl-c to quit)

-- open localhost:9160
-- developing and sending a chart to the server

> import Chart.Examples
> display lineExample

> quit

#+end_src

** ghci integration

Add this to your .ghci.conf file to automatically go into :prettychart mode.

#+begin_src haskell :results output
-- :set -package prettychart
:{
:def! prettychart \_ -> pure $ unlines [
  "import Prettychart",
  "(sendChart, quitChartServer) <- startChartServer Nothing",
  "printc=printChart False sendChart",
  ":set -interactive-print printc"
  ]
:}

:{
:def! noprettychart \_ -> pure $ unlines [
  "quitChartServer",
  ":set -interactive-print print"
  ]
:}

:prettychart
#+end_src

#+RESULTS:
: ghci| ghci| ghci| ghci| ghci| ghci| ghci|
: > ghci| ghci| ghci| ghci| ghci|
: > Setting phasers to stun... (port 9160) (ctrl-c to quit)

#+begin_src haskell :results output
[1..200]
#+end_src

#+RESULTS:

#+begin_src haskell :results output
:noprettychart
#+end_src

* Development

#+begin_src haskell-ng :results output
:r
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XTupleSections
:set -XOverloadedLabels
import Chart
import Chart.Examples
import Optics.Core
import Prettychart.Charts
import Prettychart.Any
import Prettychart.Server
import Data.Time.Calendar
import qualified Data.Map as Map
import Data.Text (Text,pack)
import qualified Data.Text as Text
import qualified Data.Text.IO as Text
import Data.Time
import qualified Data.List as List
import Control.Category ((>>>))
import Data.Aeson
import Data.Aeson.Types
import Prettychart.Aeson
import Harpie.Array qualified as A
import Data.Mealy
print "ok"
#+end_src

#+RESULTS:
: Ok, five modules loaded.
: "ok"


** live

#+begin_src haskell-ng :results output
(display, quit) <- startChartServer Nothing
display lineExample
#+end_src

#+RESULTS:
: Setting phasers tog hsctiu>n ... (porTtr u9e1
: 60) (ctrl-c to quit)

** file server

#+begin_src haskell-ng :results output
writeChartOptions "other/test.svg" (lineExample)
#+end_src


* gradient descent

#+begin_src haskell-ng :results output
:set -Wno-incomplete-uni-patterns
import Data.ByteString qualified as B
str <- B.readFile "../goal/workspace/results/gradient-descent.json"
v = decodeStrict str :: Maybe GD
(Just gd) = v
take 2 $ isosamples gd
take 2 $ gradd gd
take 2 $ mom gd
take 2 $ adam gd
xs = isosamples gd
#+end_src

#+RESULTS:
: [(-4.0,-4.0,32.0),(-4.0,-3.9191919191919196,31.366595245383127)]
: [[-4.0,2.0],[-3.0,1.2]]
: [[-4.0,2.0],[-3.0,1.2]]
: [[-4.0,2.0],[-3.50000000025,1.5000000003125]]

ranges

#+begin_src haskell-ng :results output
space1 @(Range Double) ((\(x,_,_) -> x) <$> xs)
space1 @(Range Double) ((\(_,x,_) -> x) <$> xs)
space1 @(Range Double) ((\(_,_,x) -> x) <$> xs)

#+end_src

#+RESULTS:
: Just Range -4.0 4.0
: Just Range -4.0 4.0
: Just Range 3.2649729619425934e-3 96.0

draft gradient descent

#+begin_src haskell-ng :results output
import NumHask.Space
vs = (\(_,_,x) -> x) <$> xs
dr = unsafeSpace1 vs
evenColors = set opac' 0.7 . trimColour . over lightness' (const 0.45) . palette <$> [3 .. 7]
gap = 8 / 99.0
mksd gap (x,y,z) = SurfaceData (Rect x (x+gap) y (y+gap)) (flip mixes evenColors . project dr (Range 0 1) $ z)
sds = mksd gap <$> xs

slo = defaultSurfaceLegendOptions & set (#sloSurfaceStyle % #surfaceColors) evenColors & set #sloDataRange dr & set #sloRect (Rect 0.35 0.45 0.1 0.4) & set #sloWidth 0.1 & set (#sloAxisOptions % #ticks % #textTick % _Just % #style % #size) 0.03

dotsize = 0.016

ss = zipWith (\c g -> defaultGlyphStyle & set #glyphShape g & set #size dotsize & set #color (palette c) & set #borderColor (set lightness' 0.5 (palette c))) [0..] [CircleGlyph, SquareGlyph, EllipseGlyph 0.6]

sc = named "surface" (surfaces clear sds)
gdc = named "gd" [GlyphChart (ss!!0) (fmap (\[x,y] -> Point x y) (gradd gd))]
ac = named "adam" [GlyphChart (ss!!1) (fmap (\[x,y] -> Point x y) (adam gd))]
mc = named "mom" [GlyphChart (ss!!2) (fmap (\[x,y] -> Point x y) (mom gd))]

getc1 cs = cs & toListOf charts' & mconcat & take 1

hos = defaultHudOptions & set (#axes % each % #item % #ticks % #lineTick) Nothing & set (#axes % each % #item % #ticks % #tick % tickExtend') (Just NoTickExtend) & set #legends [ Priority 12 $ defaultLegendOptions & set #place (PlaceAbsolute (Point 0.65 (-0.15))) & set #frame Nothing & set #legendCharts [("gd", getc1 gdc), ("mom", getc1 mc),("adam", getc1 ac)] & set #legendSize 0.2 & set #scaleChartsBy 0.2 & set (#legendCharts % each % _2 % each % #chartStyle % #borderSize) 0.024]

sc' = addHud ChartAspect hos (sc <> (unnamed [BlankChart clear [Rect (-4) 4 (-4) 4]]) <> gdc <> ac <> mc)
csc = mempty @ChartOptions & set #hudOptions hos & set #chartTree sc & set (#markupOptions % #chartAspect) ChartAspect & set (#markupOptions % #cssOptions % #shapeRendering) UseCssCrisp

grc = gridReferenceChart slo
hoLegend = (mempty :: HudOptions) & set #axes [Priority 1 (view #sloAxisOptions slo & set (#ticks % #textTick % _Just % #buffer) 0.001 & set (#ticks % #glyphTick % _Just % #buffer) 0)]
grcLegend = addHud (FixedAspect (view #sloWidth slo)) hoLegend grc
ctbox = maybe one id (view styleBox' sc')
legbox = projectOnR ctbox one (view #sloRect slo)
lsc = projectChartTree legbox grcLegend

l = mempty @ChartOptions & set #chartTree (lsc <> sc') & over (#hudOptions % #frames) (<> [Priority 100 (defaultFrameOptions & set #buffer 0.1)]) & set (#markupOptions % #cssOptions % #shapeRendering) UseCssCrisp

display $ l
#+end_src

#+RESULTS:
: True

Gradient Descent chart

#+begin_src haskell-ng :results output
display $ chartGD (defaultConfigChartGD) gd
#+end_src

#+RESULTS:
: True

* Prettychart.Any Examples
** single list

*** 10 or less elements => bar chart

#+begin_src haskell-ng
xs = [0..9]
#+end_src

#+RESULTS:

#+begin_src haskell-ng :file other/list1a.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1a.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1a.svg]]

#+begin_src haskell-ng :results output
either Text.putStrLn (writeChartOptions "other/list1a.svg") $ anyChart (pack . show $ xs)
#+end_src

*** >1000 elements => histogram

#+begin_src haskell-ng
xs = sin <$> [0..2000]
#+end_src

#+RESULTS:

#+begin_src haskell-ng :file other/list1b.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1b.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1b.svg]]

*** < 1000 && > 10 => line chart

In between goes for a line chartIn between goes for a line chart.

#+begin_src haskell-ng
xs = sin . (/100) <$> [0..500]
#+end_src

#+begin_src haskell-ng :file other/list1c.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1c.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1c.svg]]

** double list
*** < 4 lists && < 10 values per list => bar chart


#+begin_src haskell-ng :results output
xs = [(1+) . sin <$> [0..8], (1+) . cos <$> [0..8]]
xs
#+end_src

#+RESULTS:
: [[1.0,1.8414709848078965,1.9092974268256817,1.1411200080598671,0.2431975046920718,4.1075725336861546e-2,0.7205845018010741,1.656986598718789,1.989358246623382],[2.0,1.5403023058681398,0.5838531634528576,1.0007503399554585e-2,0.34635637913638806,1.2836621854632262,1.960170286650366,1.7539022543433047,0.8544999661913865]]

#+begin_src haskell-ng :file other/dlista.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlista.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dlista.svg]]

*** square => surface chart

#+begin_src haskell-ng :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs
xs = iter2 (*) (fmap sin [1..20]) (fmap cos [1..20]) :: [[Double]]
:t xs
length xs
fmap length xs
#+end_src

#+RESULTS:
: xs :: [[Double]]
: 20
: [20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]


#+begin_src haskell-ng :file other/dlistb.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlistb.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dlistb.svg]]

** tuple list [(Double, Double)] => scatter

#+begin_src haskell-ng :results output
xs = zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100])
:t xs
#+end_src

#+RESULTS:
: xs
:   :: (TrigField b1, TrigField b2, Fractional b1, Fractional b2,
:       Enum b1, Enum b2) =>
:      [(b1, b2)]

#+begin_src haskell-ng :file other/dtuple.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dtuple.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dtuple.svg]]

** double tuple list [(Double, Double)] => scatter


#+begin_src haskell-ng :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs


xs = iter2 (\s (x,y) -> (s*x, s*y)) ((0.1*) <$> [1..10]) (zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100]))
:t xs
#+end_src

#+RESULTS:
: > >
: xs :: (Fractional b, Enum b, TrigField b) => [[(b, b)]]

#+begin_src haskell-ng :file other/dtupleb.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dtupleb.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dtupleb.svg]]

** (Text, Double) tuple list

#+begin_src haskell-ng
xs = (\x -> (show x, x)) <$> [0..9]
#+end_src

#+RESULTS:
#+begin_src haskell-ng :file other/tdtuple.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/tdtuple.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/tdtuple.svg]]

