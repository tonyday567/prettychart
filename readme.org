
* chart-svg-various

[[https://hackage.haskell.org/package/chart-svg-various][https://img.shields.io/hackage/v/chart-svg-various.svg]]
[[https://github.com/tonyday567/chart-svg-various/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/chart-svg-various/workflows/haskell-ci/badge.svg]]

** Next prettychart

- [ ] Chart.Any
- [ ] Chart.Socket
- [ ] rationalize chartSocketPage

- [ ] functions
  anyChart
  printChart
  startServer

- [X] can Committer use be hidden?
  yes!
- [ ] prettyChartConfig

- [ ] ["hello", "list"] segfaulted
- [ ] line charts have no hud

Current protocol:

#+begin_quote
> (send, quitServer) <- startServer
Setting phaser>s  to stun... (port 9160) (ctrl-c to quit)

-- open localhost:9160

>  printc = printChart send False
> :set -interactive-print printc


> quitServer
> [1..10]
[1,2,3,4,5,6,7,8,9,10]
#+end_quote

or

#+begin_src haskell
import Chart
> import Chart.Examples
> send unitExample
#+end_src

references:

https://hackage.haskell.org/package/javascript-bridge-0.2.0
[[https://gist.github.com/andrevdm/9560b5e31933391694811bf22e25c312][Using websockets with scotty haskell Â· GitHub]]

* Development

#+begin_src haskell :session one :results output
:r
:set prompt "> "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XTupleSections
:set -XOverloadedLabels
import qualified Prelude
import Chart hiding (quantiles)
import Optics.Core
import Chart.Various
import Chart.Any
import Chart.Various.Examples
import Chart.Socket
import Web.Rep
import Box
import FlatParse.Basic hiding (take)
import Data.Time.Calendar
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as C
import Data.Mealy
import Data.Profunctor
import Data.Maybe
import Data.Bifunctor
import NumHask.Prelude hiding ((.), id)
import NumHask.Space hiding (quantiles)
import qualified Data.Map as Map
import Data.FormatN
import qualified Data.Text as Text
import Data.Time
import Data.Mealy.Quantiles
import qualified Data.List as List
import Control.Category
print "ok"
#+end_src

#+RESULTS:
: [1 of 4] Compiling Chart.Various    ( src/Chart/Various.hs, interpreted )
: [2 of 4] Compiling Chart.Any        ( src/Chart/Any.hs, interpreted )
: [3 of 4] Compiling Chart.Socket     ( src/Chart/Socket.hs, interpreted )
: [4 of 4] Compiling Chart.Various.Examples ( src/Chart/Various/Examples.hs, interpreted )
: Ok, four modules loaded.
: ghci> Ok, four modules loaded.
: ok

* Chart.Various Examples
** Example data

#+begin_src haskell :results output
r <- getReturns
length r
accret = scan (second' (dipure (+))) r
decay = 0.004
rs = snd <$> r
xma = scan (ma decay) rs
xstd = scan (std decay) rs
#+end_src

#+RESULTS:
: 10897

** simpleLineChart

#+begin_src haskell :results output
c = simpleLineChart 0.015 (palette1 2) (snd <$> accret)
xaxis = (5, timeXAxis 8 ((\x -> UTCTime x 0) . fst <$> accret))
yaxis = (5, defaultAxisOptions & #place .~ PlaceLeft & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
h = defaultHudOptions & #titles .~ (titlesHud "Accumulated Returns" "" "accumulated return") & #axes .~ [xaxis, yaxis]
accretChart = mempty & #charts .~ named "accret" [c] & #hudOptions .~ h :: ChartOptions
#+end_src

#+RESULTS:

#+begin_src haskell :file other/simpleline.svg :results output graphics file :exports both
writeChartOptions "other/simpleline.svg" accretChart
#+end_src

#+RESULTS:
[[file:other/simpleline.svg]]

** histChart

#+begin_src haskell :file other/hist.svg :results output graphics file :exports both
writeChartOptions "other/hist.svg" $ histChart (Range (-0.04) 0.04) 40 xma
#+end_src

#+RESULTS:
[[file:other/hist.svg]]

** scatterChart

#+begin_src haskell
maVstd = zipWith Point (take 500 xma) (taker 500 xstd)
#+end_src

#+RESULTS:

#+begin_src haskell :results output
c = scatterChart [maVstd]
xaxis = (5, defaultAxisOptions & #place .~ PlaceBottom & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
yaxis = (5, defaultAxisOptions & #place .~ PlaceLeft & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
h = defaultHudOptions & #titles .~ (titles3 8 ("scatter", "ma", "std")) & #axes .~ [xaxis, yaxis]
xsChart = mempty & #charts .~ unnamed c & #hudOptions .~ h :: ChartOptions
#+end_src

#+RESULTS:

#+begin_src haskell :file other/scatter.svg :results output graphics file :exports both
writeChartOptions "other/scatter.svg" xsChart
#+end_src

#+RESULTS:
[[file:other/scatter.svg]]
** quantileChart

#+begin_src haskell :results output
qs = [0.01, 0.1, 0.5, 0.9, 0.99]
qss = fmap (taker 1000) $ List.transpose $ scan (Data.Mealy.Quantiles.quantiles 0.99 qs) (snd <$> r)
c = quantileChart (quantileNames qs) ( blendMidLineStyles (length qss) 0.005 (Colour 0.7 0.1 0.3 0.5, Colour 0.1 0.4 0.8 1)) qss
xaxis = (5, timeXAxis 8 (taker 1000 $ (\x -> UTCTime x 0) . fst <$> accret))
yaxis = (5, defaultAxisOptions & #place .~ PlaceLeft & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
c' = c & (#hudOptions % #axes) .~ [xaxis,yaxis] & #markupOptions % #markupHeight .~ 600
#+end_src

#+begin_src haskell :file other/quantile.svg :results output graphics file :exports both
writeChartOptions "other/quantile.svg" c'
#+end_src

#+RESULTS:
[[file:other/quantile.svg]]

** quantileHistChart

#+begin_src haskell :results output
qs = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.99]
qslast = Data.Mealy.fold (Data.Mealy.Quantiles.quantiles 0.99 qs) (snd <$> r)
c = quantileHistChart (Just $ quantileNames qs) qs qslast
#+end_src

#+RESULTS:

#+begin_src haskell :file other/qhist.svg :results output graphics file :exports both
writeChartOptions "other/qhist.svg" c
#+end_src

#+RESULTS:
[[file:other/qhist.svg]]

** digitChart

#+begin_src haskell :results output
qs = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
digits = scan (digitize 0.99 qs) (snd <$> taker 1000 r)
c = digitChart ((\x -> UTCTime x 0) . fst <$> taker 1000 r) (fromIntegral <$> digits)
#+end_src

#+RESULTS:

#+begin_src haskell :file other/digit.svg :results output graphics file :exports both
writeChartOptions "other/digit.svg" c
#+end_src

#+RESULTS:
[[file:other/digit.svg]]

** digitSurfaceChart

        #+begin_src haskell :results output
qs = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
d1 = ((,) <$> (ma 0.95 >>> digitize 0.99 qs) <*> (std 0.95 >>> digitize 0.99 qs))
:t d1
        #+end_src

#+RESULTS:
: d1 :: Mealy Double (Int, Int)

#+begin_src haskell :results output
ds = scan d1 (taker 5000 $ snd <$> r)
c = digitSurfaceChart defaultSurfaceStyle (defaultSurfaceLegendOptions dark "legend") ("ma versus std deciles", "ma", "std") (quantileNames qs) ds
#+end_src

#+RESULTS:

#+begin_src haskell :file other/digitsurface.svg :results output graphics file :exports both
writeChartOptions "other/digitsurface.svg" $ mempty & #charts .~ c
#+end_src

#+RESULTS:
[[file:other/digitsurface.svg]]

* Chart.Any Examples
** single list

*** 10 or less elements => bar chart

#+begin_src haskell
xs = [0..9]
#+end_src

#+RESULTS:

#+begin_src haskell :file other/list1a.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1a.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1a.svg]]

#+begin_src haskell :results output
either Text.putStrLn (writeChartOptions "other/list1a.svg") $ anyChart (pack . show $ xs)
#+end_src

*** >1000 elements => histogram

#+begin_src haskell
xs = sin <$> [0..2000]
#+end_src

#+RESULTS:

#+begin_src haskell :file other/list1b.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1b.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1b.svg]]

*** < 1000 && > 10 => line chart

In between goes for a line chartIn between goes for a line chart.

#+begin_src haskell
xs = sin . (/100) <$> [0..500]
#+end_src

#+begin_src haskell :file other/list1c.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1c.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1c.svg]]

** double list
*** < 4 lists && < 10 values per list => bar chart


#+begin_src haskell :results output
xs = [(1+) . sin <$> [0..8], (1+) . cos <$> [0..8]]
xs
#+end_src

#+RESULTS:
: [[1.0,1.8414709848078965,1.9092974268256817,1.1411200080598671,0.2431975046920718,4.1075725336861546e-2,0.7205845018010741,1.656986598718789,1.989358246623382],[2.0,1.5403023058681398,0.5838531634528576,1.0007503399554585e-2,0.34635637913638806,1.2836621854632262,1.960170286650366,1.7539022543433047,0.8544999661913865]]

#+begin_src haskell :file other/dlista.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlista.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dlista.svg]]


*** square => surface chart

#+begin_src haskell :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs
xs = iter2 (*) (fmap sin [1..20]) (fmap cos [1..20]) :: [[Double]]
:t xs
length xs
fmap length xs
#+end_src

#+RESULTS:
: xs :: [[Double]]
: 20
: [20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]

FIXME: segfaulted!
#+begin_src haskell :file other/dlistb.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlistb.svg") $ anyChart (pack . show $ xs)
#+end_src

*** anything else => line chart

#+begin_src haskell :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs
xs = iter2 (*) [1..10] (fmap (sin . (0.05*)) [1..100])
:t xs
length xs
fmap length xs
#+end_src

#+RESULTS:
: xs :: (Enum b, TrigField b, Fractional b) => [[b]]
: 10
: [100,100,100,100,100,100,100,100,100,100]

#+begin_src haskell :file other/dlistc.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlistc.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dlistc.svg]]

** tuple list [(Double, Double)] => scatter

#+begin_src haskell :results output
xs = zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100])
:t xs
#+end_src

#+RESULTS:
: xs
:   :: (TrigField b1, TrigField b2, Fractional b1, Fractional b2,
:       Enum b1, Enum b2) =>
:      [(b1, b2)]

#+begin_src haskell :file other/dtuple.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dtuple.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dtuple.svg]]

** double tuple list [(Double, Double)] => scatter


#+begin_src haskell :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs


xs = iter2 (\s (x,y) -> (s*x, s*y)) ((0.1*) <$> [1..10]) (zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100]))
:t xs
#+end_src

#+RESULTS:
: > >
: xs :: (Fractional b, Enum b, TrigField b) => [[(b, b)]]

#+begin_src haskell :file other/dtupleb.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dtupleb.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dtupleb.svg]]

** (Text, Double) tuple list

#+begin_src haskell
xs = (\x -> (show x, x)) <$> [0..9]
#+end_src

#+RESULTS:
#+begin_src haskell :file other/tdtuple.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/tdtuple.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/tdtuple.svg]]
