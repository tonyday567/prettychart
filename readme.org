
* chart-svg-various

[[https://hackage.haskell.org/package/chart-svg-various][https://img.shields.io/hackage/v/chart-svg-various.svg]]
[[https://github.com/tonyday567/chart-svg-various/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/chart-svg-various/workflows/haskell-ci/badge.svg]]

** Next prettychart

- [ ] Chart.Any
- [ ] Chart.Socket
- [ ] rationalize chartSocketPage
- [ ] can Committer use be hidden?

- [ ] prettyChartConfig


Current protocol:

#+begin_quote
> (c, quitServer) <- startServer
Setting phaser>s  to stun... (port 9160) (ctrl-c to quit)

>  printc = printChart c False
> :set -interactive-print printc
> quitServer
> [1..10]
[1,2,3,4,5,6,7,8,9,10]
#+end_quote

* Development

#+begin_src haskell :session one :results output
:r
:set prompt "> "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
:set -XTupleSections
:set -XOverloadedLabels
import qualified Prelude
import Chart hiding (quantiles)
import Optics.Core
import Chart.Various
import Chart.Any
import Chart.Various.Examples
import Chart.Socket
import Web.Rep
import Box
import FlatParse.Basic hiding (take)
import Data.Time.Calendar
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as C
import Data.Mealy
import Data.Profunctor
import Data.Maybe
import Data.Bifunctor
import NumHask.Prelude hiding ((.), id)
import NumHask.Space hiding (quantiles)
import qualified Data.Map as Map
import Data.FormatN
import qualified Data.Text as Text
import Data.Time
import Data.Mealy.Quantiles
import qualified Data.List as List
import Control.Category
print "ok"
#+end_src

#+RESULTS:
#+begin_example
Build profile: -w ghc-9.4.4 -O1
In order, the following will be built (use -v for more details):
 - chart-svg-various-0.1.0 (lib) (configuration changed)
Configuring library for chart-svg-various-0.1.0..
Preprocessing library for chart-svg-various-0.1.0..
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
[1 of 4] Compiling Chart.Various    ( src/Chart/Various.hs, interpreted )
[2 of 4] Compiling Chart.Any        ( src/Chart/Any.hs, interpreted )
[3 of 4] Compiling Chart.Socket     ( src/Chart/Socket.hs, interpreted )

src/Chart/Socket.hs:65:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
[4 of 4] Compiling Chart.Various.Examples ( src/Chart/Various/Examples.hs, interpreted )
Failed, three modules loaded.
ghci> [3 of 4] Compiling Chart.Socket     ( src/Chart/Socket.hs, interpreted )

src/Chart/Socket.hs:65:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
Failed, three modules loaded.
>
<no location info>: error:
    Could not load module ‘Chart.Socket’
    It is a member of the hidden package ‘chart-svg-various-0.1.0’.
    Perhaps you need to add ‘chart-svg-various’ to the build-depends in your .cabal file.
ok
#+end_example

* Chart.Socket

** web-rep/box attempt
127.0.0.1/9160

  #+begin_src haskell :results output
:t serveSocketBox defaultSocketConfig chartSocketPage
  #+end_src

#+RESULTS:
: serveSocketBox defaultSocketConfig chartSocketPage
:   :: Box IO Text Text -> IO ()

#+begin_src haskell
cbw = codeBoxWith (defaultCodeBoxConfig & #codeBoxPage .~ chartSocketPage)
committerCbw = fmap committer cbw
:t committerCbw
#+end_src

#+RESULTS:
: committerCbw :: Codensity IO (Committer IO [Code])

Codensity IO (Box IO [Code] (Text, Text))

#+begin_src haskell :results output
import Data.Functor.Contravariant

chartCommitter = contramap ((\x -> [Replace "chart" x]) . renderChartOptions) <$> committerCbw
:t chartCommitter
#+end_src

#+RESULTS:
: >
: chartCommitter :: Codensity IO (Committer IO ChartOptions)

 #+begin_src haskell
:t fmap (\c -> printChart c True) chartCommitter
 #+end_src

#+RESULTS:
: fmap (\c -> printChart c True) chartCommitter
:   :: Show a => Codensity IO (a -> IO ())

#+begin_src haskell
import Control.Monad.Codensity
#+end_src

#+RESULTS:

#+begin_src haskell :results output
cprint <- lowerCodensity (fmap (\c -> printChart c True) chartCommitter)
#+end_src

#+begin_src haskell
printChart' [1..9]
#+end_src



#+RESULTS:
: Setting phasers to st[1,2,3,4,5,6,7,8,9]

The print function needs to be of the form:

#+begin_quote
C a => a -> IO ()
#+end_quote

#+begin_src haskell
:t toBoxM
#+end_src

#+RESULTS:
: toBoxM :: Queue a -> IO (Box IO a a, IO ())


#+begin_src haskell
:t chartAny
#+end_src

#+RESULTS:
: <interactive>:1:1: error: Variable not in scope: chartAny


** chartServer

https://hackage.haskell.org/package/javascript-bridge-0.2.0

- [ ] middleware
- [ ] serve up html with a websocket in it
- [ ] separately, send SVG to the page

  [[https://gist.github.com/andrevdm/9560b5e31933391694811bf22e25c312][Using websockets with scotty haskell · GitHub]]

- serveSocketBox with stdout as an emitter.
- stdin as the committer
- stdin "q" as a quit

#+begin_src haskell
:t serveSocketBox defaultSocketConfig chartSocketPage (Box toStdout (replace "chart" <$> fromStdin))
#+end_src

#+RESULTS:
: serveSocketBox defaultSocketConfig chartSocketPage (Box toStdout (replace "chart" <$> fromStdin))
:   :: IO ()

#+begin_src haskell
:t fmap (replace "chart") fromStdin
#+end_src

#+RESULTS:
: fmap (replace "chart") fromStdin :: Emitter IO Text

#+begin_src haskell
(c, quitServer) <- startServer'
printChart c False [0..3000]
printc = printChart c False
:set -interactive-print printc
#+end_src

* Chart.Various Examples
** Example data

#+begin_src haskell :results output
r <- getReturns
length r
accret = scan (second' (dipure (+))) r
decay = 0.004
rs = snd <$> r
xma = scan (ma decay) rs
xstd = scan (std decay) rs
#+end_src

#+RESULTS:
: 10897

** simpleLineChart

#+begin_src haskell :results output
c = simpleLineChart 0.015 (palette1 2) (snd <$> accret)
xaxis = (5, timeXAxis 8 ((\x -> UTCTime x 0) . fst <$> accret))
yaxis = (5, defaultAxisOptions & #place .~ PlaceLeft & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
h = defaultHudOptions & #titles .~ (titlesHud "Accumulated Returns" "" "accumulated return") & #axes .~ [xaxis, yaxis]
accretChart = mempty & #charts .~ named "accret" [c] & #hudOptions .~ h :: ChartOptions
#+end_src

#+RESULTS:

#+begin_src haskell :file other/simpleline.svg :results output graphics file :exports both
writeChartOptions "other/simpleline.svg" accretChart
#+end_src

#+RESULTS:
[[file:other/simpleline.svg]]

** histChart

#+begin_src haskell :file other/hist.svg :results output graphics file :exports both
writeChartOptions "other/hist.svg" $ histChart (Range (-0.04) 0.04) 40 xma
#+end_src

#+RESULTS:
[[file:other/hist.svg]]

** scatterChart

#+begin_src haskell
maVstd = zipWith Point (take 500 xma) (taker 500 xstd)
#+end_src

#+RESULTS:

#+begin_src haskell :results output
c = scatterChart [maVstd]
xaxis = (5, defaultAxisOptions & #place .~ PlaceBottom & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
yaxis = (5, defaultAxisOptions & #place .~ PlaceLeft & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
h = defaultHudOptions & #titles .~ (titles3 8 ("scatter", "ma", "std")) & #axes .~ [xaxis, yaxis]
xsChart = mempty & #charts .~ unnamed c & #hudOptions .~ h :: ChartOptions
#+end_src

#+RESULTS:

#+begin_src haskell :file other/scatter.svg :results output graphics file :exports both
writeChartOptions "other/scatter.svg" xsChart
#+end_src

#+RESULTS:
[[file:other/scatter.svg]]
** quantileChart

#+begin_src haskell :results output
qs = [0.01, 0.1, 0.5, 0.9, 0.99]
qss = fmap (taker 1000) $ List.transpose $ scan (Data.Mealy.Quantiles.quantiles 0.99 qs) (snd <$> r)
c = quantileChart (quantileNames qs) ( blendMidLineStyles (length qss) 0.005 (Colour 0.7 0.1 0.3 0.5, Colour 0.1 0.4 0.8 1)) qss
xaxis = (5, timeXAxis 8 (taker 1000 $ (\x -> UTCTime x 0) . fst <$> accret))
yaxis = (5, defaultAxisOptions & #place .~ PlaceLeft & #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend)
c' = c & (#hudOptions % #axes) .~ [xaxis,yaxis] & #markupOptions % #markupHeight .~ 600
#+end_src

#+begin_src haskell :file other/quantile.svg :results output graphics file :exports both
writeChartOptions "other/quantile.svg" c'
#+end_src

#+RESULTS:
[[file:other/quantile.svg]]

** quantileHistChart

#+begin_src haskell :results output
qs = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.99]
qslast = Data.Mealy.fold (Data.Mealy.Quantiles.quantiles 0.99 qs) (snd <$> r)
c = quantileHistChart (Just $ quantileNames qs) qs qslast
#+end_src

#+RESULTS:

#+begin_src haskell :file other/qhist.svg :results output graphics file :exports both
writeChartOptions "other/qhist.svg" c
#+end_src

#+RESULTS:
[[file:other/qhist.svg]]

** digitChart

#+begin_src haskell :results output
qs = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
digits = scan (digitize 0.99 qs) (snd <$> taker 1000 r)
c = digitChart ((\x -> UTCTime x 0) . fst <$> taker 1000 r) (fromIntegral <$> digits)
#+end_src

#+RESULTS:

#+begin_src haskell :file other/digit.svg :results output graphics file :exports both
writeChartOptions "other/digit.svg" c
#+end_src

#+RESULTS:
[[file:other/digit.svg]]

** digitSurfaceChart

        #+begin_src haskell :results output
qs = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
d1 = ((,) <$> (ma 0.95 >>> digitize 0.99 qs) <*> (std 0.95 >>> digitize 0.99 qs))
:t d1
        #+end_src

#+RESULTS:
: d1 :: Mealy Double (Int, Int)

#+begin_src haskell :results output
ds = scan d1 (taker 5000 $ snd <$> r)
c = digitSurfaceChart defaultSurfaceStyle (defaultSurfaceLegendOptions dark "legend") ("ma versus std deciles", "ma", "std") (quantileNames qs) ds
#+end_src

#+RESULTS:

#+begin_src haskell :file other/digitsurface.svg :results output graphics file :exports both
writeChartOptions "other/digitsurface.svg" $ mempty & #charts .~ c
#+end_src

#+RESULTS:
[[file:other/digitsurface.svg]]

* Chart.Any Examples
** single list

*** 10 or less elements => bar chart

#+begin_src haskell
xs = [0..9]
#+end_src

#+RESULTS:

#+begin_src haskell :file other/list1a.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1a.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1a.svg]]

#+begin_src haskell :results output
either Text.putStrLn (writeChartOptions "other/list1a.svg") $ anyChart (pack . show $ xs)
#+end_src

*** >1000 elements => histogram

#+begin_src haskell
xs = sin <$> [0..2000]
#+end_src

#+RESULTS:

#+begin_src haskell :file other/list1b.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1b.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1b.svg]]

*** < 1000 && > 10 => line chart

In between goes for a line chartIn between goes for a line chart.

#+begin_src haskell
xs = sin . (/100) <$> [0..500]
#+end_src

#+RESULTS:


#+begin_src haskell :file other/list1c.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/list1c.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/list1c.svg]]

** double list
*** < 4 lists && < 10 values per list => bar chart


#+begin_src haskell :results output
xs = [(1+) . sin <$> [0..8], (1+) . cos <$> [0..8]]
xs
#+end_src

#+RESULTS:
: [[1.0,1.8414709848078965,1.9092974268256817,1.1411200080598671,0.2431975046920718,4.1075725336861546e-2,0.7205845018010741,1.656986598718789,1.989358246623382],[2.0,1.5403023058681398,0.5838531634528576,1.0007503399554585e-2,0.34635637913638806,1.2836621854632262,1.960170286650366,1.7539022543433047,0.8544999661913865]]

#+begin_src haskell :file other/dlista.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlista.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dlista.svg]]


*** square => surface chart

#+begin_src haskell :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs
xs = iter2 (*) (fmap sin [1..20]) (fmap cos [1..20]) :: [[Double]]
:t xs
length xs
fmap length xs
#+end_src

#+RESULTS:
: xs :: [[Double]]
: 20
: [20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]

FIXME: segfaulted!
#+begin_src haskell :file other/dlistb.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlistb.svg") $ anyChart (pack . show $ xs)
#+end_src

*** anything else => line chart

#+begin_src haskell :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs
xs = iter2 (*) [1..10] (fmap (sin . (0.05*)) [1..100])
:t xs
length xs
fmap length xs
#+end_src

#+RESULTS:
: xs :: (Enum b, TrigField b, Fractional b) => [[b]]
: 10
: [100,100,100,100,100,100,100,100,100,100]

#+begin_src haskell :file other/dlistc.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dlistc.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dlistc.svg]]

** tuple list [(Double, Double)] => scatter

#+begin_src haskell :results output
xs = zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100])
:t xs
#+end_src

#+RESULTS:
: xs
:   :: (TrigField b1, TrigField b2, Fractional b1, Fractional b2,
:       Enum b1, Enum b2) =>
:      [(b1, b2)]

#+begin_src haskell :file other/dtuple.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dtuple.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dtuple.svg]]

** double tuple list [(Double, Double)] => scatter


#+begin_src haskell :results output
iter2 f xs ys = f <$> xs <&> flip fmap ys -- or (\a -> f a <$> ys) <$> xs


xs = iter2 (\s (x,y) -> (s*x, s*y)) ((0.1*) <$> [1..10]) (zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100]))
:t xs
#+end_src

#+RESULTS:
: > >
: xs :: (Fractional b, Enum b, TrigField b) => [[(b, b)]]

#+begin_src haskell :file other/dtupleb.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/dtupleb.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/dtupleb.svg]]

** (Text, Double) tuple list

#+begin_src haskell
xs = (\x -> (show x, x)) <$> [0..9]
#+end_src

#+RESULTS:
#+begin_src haskell :file other/tdtuple.svg :results output graphics file :exports both
either Text.putStrLn (writeChartOptions "other/tdtuple.svg") $ anyChart (pack . show $ xs)
#+end_src

#+RESULTS:
[[file:other/tdtuple.svg]]
